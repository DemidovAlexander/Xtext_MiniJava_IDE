/*
 * generated by Xtext 2.9.1
 */
package demidov.projects.scoping

import org.eclipse.xtext.scoping.IScope
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import demidov.projects.miniJava.MiniJavaPackage
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.FilteringScope
import org.eclipse.xtext.resource.IEObjectDescription
import com.google.common.base.Predicate
import demidov.projects.miniJava.Method
import demidov.projects.miniJava.Statement
import demidov.projects.miniJava.Variable
import java.util.HashSet
import java.util.ArrayList
import demidov.projects.miniJava.ClassDecl
import demidov.projects.miniJava.MethodCall
import demidov.projects.utils.CommonUtils
import demidov.projects.miniJava.Expr
import demidov.projects.miniJava.Point

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class MiniJavaScopeProvider extends AbstractMiniJavaScopeProvider {

	override IScope getScope(EObject context, EReference reference) {
		
		if(context instanceof ClassDecl && reference == MiniJavaPackage.Literals.CLASS_DECL__EXTENDED_CLASS) {			
			
        	val rootElement = EcoreUtil2.getRootContainer(context);
        	val candidates = EcoreUtil2.getAllContentsOfType(rootElement, ClassDecl);

        	val existingScope = Scopes.scopeFor(candidates);
        	
        	val filteredScope = new FilteringScope(existingScope, new Predicate<IEObjectDescription>() {
            		override apply(IEObjectDescription input) {
              			return input.getEObjectOrProxy() != context;
            		}
        		}
        	);
        	
        	return filteredScope;
		}
		
		if(context instanceof MethodCall && reference == MiniJavaPackage.Literals.METHOD_CALL__METHOD) {    	
			val pointExpression = EcoreUtil2.getContainerOfType(context, Point);
			
			if ( pointExpression == null
				|| pointExpression.left == null ) {
					   	
        		return Scopes.scopeFor(new ArrayList<EObject>());
        	}
        	
        	val exprType = CommonUtils::getExpressionType(pointExpression.left)
			
			if (exprType == null) {        	
        		return Scopes.scopeFor(new ArrayList<EObject>());
        	}
			
			val classDecl = exprType.classDecl;
        	
        	if (classDecl == null) {        	
        		return Scopes.scopeFor(new ArrayList<EObject>());
        	}
        	
        	return Scopes.scopeFor(CommonUtils::getMethodsForClass(classDecl));
		}
		
		if( (context instanceof Statement && reference == MiniJavaPackage.Literals.STATEMENT__VARIABLE)
			|| (context instanceof Expr && reference == MiniJavaPackage.Literals.EXPR__VARIABLE) ) {
				
			var variablesNames = new HashSet<String>();
			var ArrayList<Variable> variablesCandidates = new ArrayList<Variable>();
			
			val method = EcoreUtil2.getContainerOfType(context, Method);
			var classDecl = EcoreUtil2.getContainerOfType(context, ClassDecl);
			
			if (classDecl == null) {
				return Scopes.scopeFor(new ArrayList<EObject>());
			}
			
			if ( method != null && classDecl.methodDeclarations.contains(method) ) {
					   	        	
        		variablesCandidates.addAll(method.formalVarDeclarations);
			
				for (varDeclaration : method.localVarDeclarations) {
					variablesCandidates.add(varDeclaration.variable);
				}
			}
			
			for (variablesCandidate : variablesCandidates) {
        		variablesNames.add(variablesCandidate.name)
        	}
        	
        	do {
        		for (varDeclaration : classDecl.varDeclarations) {
        			val variable = varDeclaration.variable;     
        		
        			if (!variablesNames.contains(variable.name)) {
        				variablesNames.add(variable.name)
        				variablesCandidates.add(variable);
        			}
        		}
        		
        		classDecl = classDecl.extendedClass;         		       		
        	} while (classDecl != null)
        	
        	val scope = Scopes.scopeFor(variablesCandidates);
        	        	
        	return scope;
		}

		return super.getScope(context, reference);
	}
}
