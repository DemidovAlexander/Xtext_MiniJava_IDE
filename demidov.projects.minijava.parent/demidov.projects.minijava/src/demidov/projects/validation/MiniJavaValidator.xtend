/*
 * generated by Xtext 2.9.1
 */
package demidov.projects.validation

import org.eclipse.xtext.validation.Check
import demidov.projects.miniJava.MiniJavaPackage
import demidov.projects.miniJava.Statement
import demidov.projects.miniJava.Expr
import demidov.projects.miniJava.ClassDecl
import demidov.projects.miniJava.Method
import demidov.projects.miniJava.MethodCall
import demidov.projects.utils.CommonUtils
import demidov.projects.miniJava.Program
import org.eclipse.xtext.EcoreUtil2
import demidov.projects.miniJava.Variable

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MiniJavaValidator extends AbstractMiniJavaValidator {
	
	public static val INVALID_NAME = 'invalidName'
	public static val CYCLYC_DEPENDENCE = 'cyclicDependence'
	public static val DUPLICATE_NAMES = 'duplicateNames'
	public static val WRONG_PARAMETERS = 'wrongParameters'
	public static val WRONG_RETURN = 'wrongReturn'
	public static val NO_RETURN = 'noReturn'
	public static val NOT_ARRAY = 'notArray'
	public static val NOT_INT = 'notInt'
	public static val NOT_BOOLEAN = 'notBoolean'	
	public static val TYPE_MISMATCH = 'typeMismatch'
	public static val WRONG_METHOD = 'wrongMethod'
	public static val WRONG_INSTANTIATION = 'wrongInstantiation'

	@Check(FAST)
	def checkClassName(ClassDecl classDecl) {
		if (!Character.isUpperCase(classDecl.name.charAt(0))) {
			warning('Name should start with a capital',
					MiniJavaPackage.Literals.CLASS_DECL__NAME,
					INVALID_NAME);
		}
	}
	
	// Cyclic dependance		
	@Check(FAST)
	def checkCyclicDependance(ClassDecl classDecl) {
		var extendedClass = classDecl.extendedClass
		while (extendedClass != null && extendedClass != classDecl) {
			extendedClass = extendedClass.extendedClass;
		}
		
		if (extendedClass != null) {
			error('Cyclic dependence',
					MiniJavaPackage.Literals.CLASS_DECL__NAME,
					CYCLYC_DEPENDENCE);
		}
	}
	
	// Duplicate names of the classes
	@Check(FAST)
	def checkDuplicateClassNames(ClassDecl classDecl) {
		val program = EcoreUtil2.getContainerOfType(classDecl, Program);

        for (currentClassDecl : program.classDeclarations) {
        	if ( classDecl.name.equals(currentClassDecl.name)
        		&& classDecl != currentClassDecl ) {
        				
				error('Duplicate names of the classes',
					MiniJavaPackage.Literals.CLASS_DECL__NAME,
					DUPLICATE_NAMES);
			}
		}
	}
	
	// Duplicate names of the classes
	@Check(FAST)
	def checkDuplicateMethodNames(Method method) {
		val classDecl = EcoreUtil2.getContainerOfType(method, ClassDecl);

        for (currentMethod : classDecl.methodDeclarations) {
        	if ( method.name.equals(currentMethod.name)
        		&& method != currentMethod ) {
        				
				error('Duplicate names of the methods',
					MiniJavaPackage.Literals.METHOD__NAME,
					DUPLICATE_NAMES);
			}
		}
	}
	
	// Duplicate names of the variables
	@Check(FAST)
	def checkDuplicateVariablesNames(Variable variable) {
		val method = EcoreUtil2.getContainerOfType(variable, Method);		
		val classDecl = EcoreUtil2.getContainerOfType(variable, ClassDecl);
		
		if (!classDecl.methodDeclarations.contains(method)) { // class variable
        	for (varDeclaration : classDecl.varDeclarations) {
        		if ( varDeclaration.variable.name.equals(variable.name)
        			&& varDeclaration.variable != variable ) {
        				
					error('Duplicate names of the variables',
						MiniJavaPackage.Literals.VARIABLE__NAME,
						DUPLICATE_NAMES);
				}
			}
		} else { // method variable
		
			for (methodFormalVariable : method.formalVarDeclarations) {
        		if ( methodFormalVariable.name.equals(variable.name)
        			&& methodFormalVariable != variable ) {
        				
					error('Duplicate names of the variables',
						MiniJavaPackage.Literals.VARIABLE__NAME,
						DUPLICATE_NAMES);
					return;
				}
			}

        	for (methodLocalVarDeclaration : method.localVarDeclarations) {
        		if ( methodLocalVarDeclaration.variable.name.equals(variable.name)
        			&& methodLocalVarDeclaration.variable != variable ) {
        				
					error('Duplicate names of the variables',
						MiniJavaPackage.Literals.VARIABLE__NAME,
						DUPLICATE_NAMES);
					return;
				}
			}
		}
		
	}
	
	// Wrong method parameters
	@Check(FAST)
	def checkMethodParameters(MethodCall methodCall) {
		val formalVariables = methodCall.method.formalVarDeclarations
		val parameters = methodCall.parameters
		
		if (formalVariables.length != parameters.length) {
			error('Wrong number of parameters',
				MiniJavaPackage.Literals.METHOD_CALL__METHOD,
				WRONG_PARAMETERS);
		} else {		
			for (i : 0 ..< parameters.length) {
				val type = CommonUtils::getExpressionType( parameters.get(i) );
			
				if ( formalVariables.get(i).variableType.classDecl != null
					&& !CommonUtils::checkCompatibleClassTypes(
						formalVariables.get(i).variableType.classDecl, type.classDecl ) ) {
					
					error('Type mismatch in the parameters of the method',
						MiniJavaPackage.Literals.METHOD_CALL__METHOD,
						TYPE_MISMATCH);						
					return;
				}
						
				if ( formalVariables.get(i).variableType.typeName != null 
					&& ( type.typeName == null
						|| !formalVariables.get(i).variableType.typeName.equals(type.typeName) ) ) {
						
					error('Type mismatch in the parameters of the method',
						MiniJavaPackage.Literals.METHOD_CALL__METHOD,
							TYPE_MISMATCH);					
					return;
				}	
			}
		}
	}
	
	// No return statement for the method
	@Check(FAST)
	def checkReturnExistance(Method method) {
		if (method.returnExpression == null) {
					
			error('No return statement for the method',
				MiniJavaPackage.Literals.METHOD__RETURN_EXPRESSION,
				NO_RETURN);
		}
	}	
		
	// Wrong type of the return expression
	@Check(FAST)
	def checkReturnExpression(Method method) {
		val type = CommonUtils::getExpressionType(method.returnExpression);
		
		if ( !CommonUtils::checkCompatibleClassTypes(method.methodType.classDecl, type.classDecl )
			|| (type.typeName != null 
				&& ( method.methodType.typeName == null
					|| type.typeName != method.methodType.typeName ) ) ) {
					
			error('Wrong type of the return expression',
				MiniJavaPackage.Literals.METHOD__RETURN_EXPRESSION,
				WRONG_RETURN);
		}
	}
	
	// Wrong type in condition
	@Check(FAST)
	def checkConditionParameter(Statement statement) {
		if ( statement.statementType.matches('if|while') ) {
			val type = CommonUtils::getExpressionType(statement.firstExpression);
			if ( type.typeName == null
				|| !type.typeName.equals('boolean') ) {

				error('Wrong type in condition, should be boolean',
					MiniJavaPackage.Literals.STATEMENT__FIRST_EXPRESSION,
					NOT_BOOLEAN);
			}
		}
	}
	
	// Wrong type in println	
	@Check(FAST)
	def checkPrintlnParameter(Statement statement) {
		if ( statement.statementType.equals('System.out.println') ) {
			val type = CommonUtils::getExpressionType(statement.firstExpression);
			if ( type.typeName == null
				|| !type.typeName.equals('int') ) {

				error('The variable isn\'t an array',
					MiniJavaPackage.Literals.STATEMENT__FIRST_EXPRESSION,
					NOT_INT);
			}
		}
	}
	
	// Wrong type in assignment
	@Check(FAST)
	def checkArrayElementAssignment(Statement statement) {
		if ( statement.statementType.equals('=') 
			&& statement.isArrayElementAssignment ) {		
						
			if (statement.variable.variableType.typeName == null
				|| !statement.variable.variableType.typeName.equals('[') ) {
					
				error('The variable isn\'t an array',
					MiniJavaPackage.Literals.STATEMENT__VARIABLE,
					NOT_ARRAY);
				return;
			}
			
			val firstType = CommonUtils::getExpressionType(statement.firstExpression);
			val secondType = CommonUtils::getExpressionType(statement.secondExpression);
				
			if ( firstType.typeName == null
				|| !firstType.typeName.equals('int') ) {
					
				error('Wrong type, should be int',
					MiniJavaPackage.Literals.STATEMENT__FIRST_EXPRESSION,
					NOT_INT);
				return;
			}
			
			if ( secondType.typeName == null
				|| !secondType.typeName.equals('int') ) {

				error('Wrong type, should be int',
					MiniJavaPackage.Literals.STATEMENT__SECOND_EXPRESSION,
					NOT_INT);
				return;
			}
		}
	}
	
	@Check(FAST)
	def checkAssignment(Statement statement) {
		if ( statement.statementType.equals('=') 
			&& !statement.isArrayElementAssignment ) {	
				
			val type = CommonUtils::getExpressionType(statement.firstExpression);
			
			if ( statement.variable.variableType.classDecl != null
				&& !CommonUtils::checkCompatibleClassTypes(statement.variable.variableType.classDecl, type.classDecl) ) {
					
				error('Type mismatch',
					MiniJavaPackage.Literals.STATEMENT__FIRST_EXPRESSION,
					TYPE_MISMATCH);
				return;
			}
						
			if ( statement.variable.variableType.typeName != null 
				&& ( type.typeName == null
					|| !statement.variable.variableType.typeName.equals(type.typeName) ) ) {
						
				error('Type mismatch',
					MiniJavaPackage.Literals.STATEMENT__FIRST_EXPRESSION,
					TYPE_MISMATCH);	
				return;	
			}
		}
	}
	
	// Wrong type in logic expression
	@Check(FAST)
	def checkLessParameter(Expr expression) {
		if ( (expression.expressionType != null) && expression.expressionType.equals('&&') ) {
			val leftType = CommonUtils::getExpressionType(expression.left);
			val rightType = CommonUtils::getExpressionType(expression.right);
			
			if ( leftType.typeName == null
				|| !leftType.typeName.equals('boolean') ) {
					
				error('Wrong type, should be boolean',
					MiniJavaPackage.Literals.EXPR__LEFT,
					NOT_BOOLEAN);
				return;
			}
			
			if ( rightType.typeName == null
				|| !rightType.typeName.equals('boolean') ) {

				error('Wrong type, should be boolean',
					MiniJavaPackage.Literals.EXPR__RIGHT,
					NOT_BOOLEAN);
				return;
			}
		}
	}
	
	// Wrong type in less, addition or multiplication expression
	@Check(FAST)
	def checkIntExprParameter(Expr expression) {
		if ( (expression.expressionType != null) && expression.expressionType.matches('<|\\+|-|\\*') ) {
			val leftType = CommonUtils::getExpressionType(expression.left);
			val rightType = CommonUtils::getExpressionType(expression.right);
			
			if ( leftType.typeName == null
				|| !leftType.typeName.equals('int') ) {
					
				error('Wrong type, should be int',
					MiniJavaPackage.Literals.EXPR__LEFT,
					NOT_INT);
					
			} else if ( rightType.typeName == null
				|| !rightType.typeName.equals('int') ) {

				error('Wrong type, should be int',
					MiniJavaPackage.Literals.EXPR__RIGHT,
					NOT_INT);
			}
		}
	}
	
	// Wrong type in negation expression
	@Check(FAST)
	def checkNegationParameter(Expr expression) {
		if ( (expression.expressionType != null) && expression.expressionType.equals('!') ) {
			val type = CommonUtils::getExpressionType(expression.right);
			if ( type.typeName == null
				|| !type.typeName.equals('boolean') ) {

				error('Wrong type, should be boolean',
					MiniJavaPackage.Literals.EXPR__RIGHT,
					NOT_BOOLEAN);
			}
		}
	}
	
	// Wrong type in point expression	
	@Check(FAST)
	def checkPointExpression(Expr expression) {
		if ( (expression.expressionType != null) && expression.expressionType.equals('.') ) {
			val type = CommonUtils::getExpressionType(expression.left);
			
			if ( type.typeName != null
				&& ( !type.typeName.equals('[')
					|| expression.right.expressionType == null
					|| !expression.right.expressionType.equals('length') ) ) {

				error('Impossible to call method for the expression',
					MiniJavaPackage.Literals.EXPR__LEFT,
					WRONG_METHOD);
			}
			
			if ( type.classDecl != null
				&& ( expression.right.methodCall == null
					|| !CommonUtils::checkMethodForClass(type.classDecl, expression.right.methodCall.method) ) ) {
						
				error('Impossible to call method for the expression',
					MiniJavaPackage.Literals.EXPR__LEFT,
					WRONG_METHOD);				
			}
		}
	}
	
	// Wrong type in square brackets expression
	@Check(FAST)
	def checkSquareBracketsExpression(Expr expression) {
		if ( (expression.expressionType != null) && expression.expressionType.equals('[') ) {
			val leftType = CommonUtils::getExpressionType(expression.left);
			val rightType = CommonUtils::getExpressionType(expression.right);
			
			if ( leftType.typeName == null
				|| !leftType.typeName.equals('[') ) {
					
				error('Wrong type, should be int array',
					MiniJavaPackage.Literals.EXPR__LEFT,
					NOT_ARRAY);
				return;
			}
				
			if ( rightType.typeName == null
				|| !rightType.typeName.equals('int') ) {

				error('Wrong type, should be int',
					MiniJavaPackage.Literals.EXPR__RIGHT,
					NOT_INT);
				return;
			}
		}
	}
	
	// Wrong new int array capacity parameter
	@Check(FAST)
	def checkNewArrayParameter(Expr expression) {
		if ( (expression.expressionType != null) && expression.expressionType.equals('new') 
			&& (expression.type == null) ) {
				
			val type = CommonUtils::getExpressionType(expression.expression);
			
			if ( type.typeName == null
				|| !type.typeName.equals('int') ) {

				error('Wrong type, should be int',
					MiniJavaPackage.Literals.EXPR__EXPRESSION,
					NOT_INT);
			}
		}
	}
	
	// Couldn't instantiate a primitive type
	@Check(FAST)
	def checkNewPrimitiveTypeExpression(Expr expression) {
		if ( (expression.expressionType != null) && expression.expressionType.equals('new') 
			&& (expression.type != null) ) {				
			
			if ( expression.type.typeName != null ) {

				error('Wrong type, should be int',
					MiniJavaPackage.Literals.EXPR__TYPE,
					WRONG_INSTANTIATION);
			}
		}
	}
}
