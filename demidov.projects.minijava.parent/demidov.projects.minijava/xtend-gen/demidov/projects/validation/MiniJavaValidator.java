/**
 * generated by Xtext 2.9.1
 */
package demidov.projects.validation;

import com.google.common.base.Objects;
import demidov.projects.miniJava.ClassDecl;
import demidov.projects.miniJava.Expr;
import demidov.projects.miniJava.Method;
import demidov.projects.miniJava.MethodCall;
import demidov.projects.miniJava.MiniJavaPackage;
import demidov.projects.miniJava.Program;
import demidov.projects.miniJava.Statement;
import demidov.projects.miniJava.Type;
import demidov.projects.miniJava.VarDeclaration;
import demidov.projects.miniJava.Variable;
import demidov.projects.utils.CommonUtils;
import demidov.projects.validation.AbstractMiniJavaValidator;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class MiniJavaValidator extends AbstractMiniJavaValidator {
  public final static String INVALID_NAME = "invalidName";
  
  public final static String CYCLYC_DEPENDENCE = "cyclicDependence";
  
  public final static String DUPLICATE_NAMES = "duplicateNames";
  
  public final static String WRONG_PARAMETERS = "wrongParameters";
  
  public final static String WRONG_RETURN = "wrongReturn";
  
  public final static String NOT_ARRAY = "notArray";
  
  public final static String NOT_INT = "notInt";
  
  public final static String NOT_BOOLEAN = "notBoolean";
  
  public final static String TYPE_MISMATCH = "typeMismatch";
  
  public final static String WRONG_METHOD = "wrongMethod";
  
  public final static String WRONG_INSTANTIATION = "wrongInstantiation";
  
  @Check(CheckType.FAST)
  public void checkClassName(final ClassDecl classDecl) {
    String _name = classDecl.getName();
    char _charAt = _name.charAt(0);
    boolean _isUpperCase = Character.isUpperCase(_charAt);
    boolean _not = (!_isUpperCase);
    if (_not) {
      this.warning("Name should start with a capital", 
        MiniJavaPackage.Literals.CLASS_DECL__NAME, 
        MiniJavaValidator.INVALID_NAME);
    }
  }
  
  @Check(CheckType.FAST)
  public void checkCyclicDependance(final ClassDecl classDecl) {
    ClassDecl extendedClass = classDecl.getExtendedClass();
    while (((!Objects.equal(extendedClass, null)) && (!Objects.equal(extendedClass, classDecl)))) {
      ClassDecl _extendedClass = extendedClass.getExtendedClass();
      extendedClass = _extendedClass;
    }
    boolean _notEquals = (!Objects.equal(extendedClass, null));
    if (_notEquals) {
      this.error("Cyclic dependence", 
        MiniJavaPackage.Literals.CLASS_DECL__NAME, 
        MiniJavaValidator.CYCLYC_DEPENDENCE);
    }
  }
  
  @Check(CheckType.FAST)
  public void checkDuplicateClassNames(final ClassDecl classDecl) {
    final Program program = EcoreUtil2.<Program>getContainerOfType(classDecl, Program.class);
    EList<ClassDecl> _classDeclarations = program.getClassDeclarations();
    for (final ClassDecl currentClassDecl : _classDeclarations) {
      boolean _and = false;
      String _name = classDecl.getName();
      String _name_1 = currentClassDecl.getName();
      boolean _equals = _name.equals(_name_1);
      if (!_equals) {
        _and = false;
      } else {
        boolean _notEquals = (!Objects.equal(classDecl, currentClassDecl));
        _and = _notEquals;
      }
      if (_and) {
        this.error("Duplicate names of the classes", 
          MiniJavaPackage.Literals.CLASS_DECL__NAME, 
          MiniJavaValidator.DUPLICATE_NAMES);
      }
    }
  }
  
  @Check(CheckType.FAST)
  public void checkDuplicateVariablesNames(final Variable variable) {
    final Method method = EcoreUtil2.<Method>getContainerOfType(variable, Method.class);
    final ClassDecl classDecl = EcoreUtil2.<ClassDecl>getContainerOfType(variable, ClassDecl.class);
    EList<Method> _methodDeclarations = classDecl.getMethodDeclarations();
    boolean _contains = _methodDeclarations.contains(method);
    boolean _not = (!_contains);
    if (_not) {
      EList<VarDeclaration> _varDeclarations = classDecl.getVarDeclarations();
      for (final VarDeclaration varDeclaration : _varDeclarations) {
        boolean _and = false;
        Variable _variable = varDeclaration.getVariable();
        String _name = _variable.getName();
        String _name_1 = variable.getName();
        boolean _equals = _name.equals(_name_1);
        if (!_equals) {
          _and = false;
        } else {
          Variable _variable_1 = varDeclaration.getVariable();
          boolean _notEquals = (!Objects.equal(_variable_1, variable));
          _and = _notEquals;
        }
        if (_and) {
          this.error("Duplicate names of the variables", 
            MiniJavaPackage.Literals.VARIABLE__NAME, 
            MiniJavaValidator.DUPLICATE_NAMES);
        }
      }
    } else {
      EList<Variable> _formalVarDeclarations = method.getFormalVarDeclarations();
      for (final Variable methodFormalVariable : _formalVarDeclarations) {
        boolean _and_1 = false;
        String _name_2 = methodFormalVariable.getName();
        String _name_3 = variable.getName();
        boolean _equals_1 = _name_2.equals(_name_3);
        if (!_equals_1) {
          _and_1 = false;
        } else {
          boolean _notEquals_1 = (!Objects.equal(methodFormalVariable, variable));
          _and_1 = _notEquals_1;
        }
        if (_and_1) {
          this.error("Duplicate names of the variables", 
            MiniJavaPackage.Literals.VARIABLE__NAME, 
            MiniJavaValidator.DUPLICATE_NAMES);
          return;
        }
      }
      EList<VarDeclaration> _localVarDeclarations = method.getLocalVarDeclarations();
      for (final VarDeclaration methodLocalVarDeclaration : _localVarDeclarations) {
        boolean _and_2 = false;
        Variable _variable_2 = methodLocalVarDeclaration.getVariable();
        String _name_4 = _variable_2.getName();
        String _name_5 = variable.getName();
        boolean _equals_2 = _name_4.equals(_name_5);
        if (!_equals_2) {
          _and_2 = false;
        } else {
          Variable _variable_3 = methodLocalVarDeclaration.getVariable();
          boolean _notEquals_2 = (!Objects.equal(_variable_3, variable));
          _and_2 = _notEquals_2;
        }
        if (_and_2) {
          this.error("Duplicate names of the variables", 
            MiniJavaPackage.Literals.VARIABLE__NAME, 
            MiniJavaValidator.DUPLICATE_NAMES);
          return;
        }
      }
    }
  }
  
  @Check(CheckType.FAST)
  public void checkMethodParameters(final MethodCall methodCall) {
    Method _method = methodCall.getMethod();
    final EList<Variable> formalVariables = _method.getFormalVarDeclarations();
    final EList<Expr> parameters = methodCall.getParameters();
    int _length = ((Object[])Conversions.unwrapArray(formalVariables, Object.class)).length;
    int _length_1 = ((Object[])Conversions.unwrapArray(parameters, Object.class)).length;
    boolean _notEquals = (_length != _length_1);
    if (_notEquals) {
      this.error("Wrong number of parameters", 
        MiniJavaPackage.Literals.METHOD_CALL__METHOD, 
        MiniJavaValidator.WRONG_PARAMETERS);
    } else {
      int _length_2 = ((Object[])Conversions.unwrapArray(parameters, Object.class)).length;
      ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _length_2, true);
      for (final Integer i : _doubleDotLessThan) {
        {
          Expr _get = parameters.get((i).intValue());
          final Type type = CommonUtils.getExpressionType(_get);
          boolean _and = false;
          Variable _get_1 = formalVariables.get((i).intValue());
          Type _variableType = _get_1.getVariableType();
          ClassDecl _classDecl = _variableType.getClassDecl();
          boolean _notEquals_1 = (!Objects.equal(_classDecl, null));
          if (!_notEquals_1) {
            _and = false;
          } else {
            Variable _get_2 = formalVariables.get((i).intValue());
            Type _variableType_1 = _get_2.getVariableType();
            ClassDecl _classDecl_1 = _variableType_1.getClassDecl();
            ClassDecl _classDecl_2 = type.getClassDecl();
            boolean _checkCompatibleClassTypes = CommonUtils.checkCompatibleClassTypes(_classDecl_1, _classDecl_2);
            boolean _not = (!_checkCompatibleClassTypes);
            _and = _not;
          }
          if (_and) {
            this.error("Type mismatch in the parameters of the method", 
              MiniJavaPackage.Literals.METHOD_CALL__METHOD, 
              MiniJavaValidator.TYPE_MISMATCH);
            return;
          }
          boolean _and_1 = false;
          Variable _get_3 = formalVariables.get((i).intValue());
          Type _variableType_2 = _get_3.getVariableType();
          String _typeName = _variableType_2.getTypeName();
          boolean _notEquals_2 = (!Objects.equal(_typeName, null));
          if (!_notEquals_2) {
            _and_1 = false;
          } else {
            boolean _or = false;
            String _typeName_1 = type.getTypeName();
            boolean _equals = Objects.equal(_typeName_1, null);
            if (_equals) {
              _or = true;
            } else {
              Variable _get_4 = formalVariables.get((i).intValue());
              Type _variableType_3 = _get_4.getVariableType();
              String _typeName_2 = _variableType_3.getTypeName();
              String _typeName_3 = type.getTypeName();
              boolean _equals_1 = _typeName_2.equals(_typeName_3);
              boolean _not_1 = (!_equals_1);
              _or = _not_1;
            }
            _and_1 = _or;
          }
          if (_and_1) {
            this.error("Type mismatch in the parameters of the method", 
              MiniJavaPackage.Literals.METHOD_CALL__METHOD, 
              MiniJavaValidator.TYPE_MISMATCH);
            return;
          }
        }
      }
    }
  }
  
  @Check(CheckType.FAST)
  public void checkReturnExpression(final Method method) {
    Expr _returnExpression = method.getReturnExpression();
    final Type type = CommonUtils.getExpressionType(_returnExpression);
    boolean _or = false;
    Type _methodType = method.getMethodType();
    ClassDecl _classDecl = _methodType.getClassDecl();
    ClassDecl _classDecl_1 = type.getClassDecl();
    boolean _checkCompatibleClassTypes = CommonUtils.checkCompatibleClassTypes(_classDecl, _classDecl_1);
    boolean _not = (!_checkCompatibleClassTypes);
    if (_not) {
      _or = true;
    } else {
      boolean _and = false;
      String _typeName = type.getTypeName();
      boolean _notEquals = (!Objects.equal(_typeName, null));
      if (!_notEquals) {
        _and = false;
      } else {
        boolean _or_1 = false;
        Type _methodType_1 = method.getMethodType();
        String _typeName_1 = _methodType_1.getTypeName();
        boolean _equals = Objects.equal(_typeName_1, null);
        if (_equals) {
          _or_1 = true;
        } else {
          String _typeName_2 = type.getTypeName();
          Type _methodType_2 = method.getMethodType();
          String _typeName_3 = _methodType_2.getTypeName();
          boolean _notEquals_1 = (!Objects.equal(_typeName_2, _typeName_3));
          _or_1 = _notEquals_1;
        }
        _and = _or_1;
      }
      _or = _and;
    }
    if (_or) {
      this.error("Wrong type of the return expression", 
        MiniJavaPackage.Literals.METHOD__RETURN_EXPRESSION, 
        MiniJavaValidator.WRONG_RETURN);
    }
  }
  
  @Check(CheckType.FAST)
  public void checkConditionParameter(final Statement statement) {
    String _statementType = statement.getStatementType();
    boolean _matches = _statementType.matches("if|while");
    if (_matches) {
      Expr _firstExpression = statement.getFirstExpression();
      final Type type = CommonUtils.getExpressionType(_firstExpression);
      boolean _or = false;
      String _typeName = type.getTypeName();
      boolean _equals = Objects.equal(_typeName, null);
      if (_equals) {
        _or = true;
      } else {
        String _typeName_1 = type.getTypeName();
        boolean _equals_1 = _typeName_1.equals("boolean");
        boolean _not = (!_equals_1);
        _or = _not;
      }
      if (_or) {
        this.error("Wrong type in condition, should be boolean", 
          MiniJavaPackage.Literals.STATEMENT__FIRST_EXPRESSION, 
          MiniJavaValidator.NOT_BOOLEAN);
      }
    }
  }
  
  @Check(CheckType.FAST)
  public void checkPrintlnParameter(final Statement statement) {
    String _statementType = statement.getStatementType();
    boolean _equals = _statementType.equals("System.out.println");
    if (_equals) {
      Expr _firstExpression = statement.getFirstExpression();
      final Type type = CommonUtils.getExpressionType(_firstExpression);
      boolean _or = false;
      String _typeName = type.getTypeName();
      boolean _equals_1 = Objects.equal(_typeName, null);
      if (_equals_1) {
        _or = true;
      } else {
        String _typeName_1 = type.getTypeName();
        boolean _equals_2 = _typeName_1.equals("int");
        boolean _not = (!_equals_2);
        _or = _not;
      }
      if (_or) {
        this.error("The variable isn\'t an array", 
          MiniJavaPackage.Literals.STATEMENT__FIRST_EXPRESSION, 
          MiniJavaValidator.NOT_INT);
      }
    }
  }
  
  @Check(CheckType.FAST)
  public void checkArrayElementAssignment(final Statement statement) {
    boolean _and = false;
    String _statementType = statement.getStatementType();
    boolean _equals = _statementType.equals("=");
    if (!_equals) {
      _and = false;
    } else {
      boolean _isIsArrayElementAssignment = statement.isIsArrayElementAssignment();
      _and = _isIsArrayElementAssignment;
    }
    if (_and) {
      boolean _or = false;
      Variable _variable = statement.getVariable();
      Type _variableType = _variable.getVariableType();
      String _typeName = _variableType.getTypeName();
      boolean _equals_1 = Objects.equal(_typeName, null);
      if (_equals_1) {
        _or = true;
      } else {
        Variable _variable_1 = statement.getVariable();
        Type _variableType_1 = _variable_1.getVariableType();
        String _typeName_1 = _variableType_1.getTypeName();
        boolean _equals_2 = _typeName_1.equals("[");
        boolean _not = (!_equals_2);
        _or = _not;
      }
      if (_or) {
        this.error("The variable isn\'t an array", 
          MiniJavaPackage.Literals.STATEMENT__VARIABLE, 
          MiniJavaValidator.NOT_ARRAY);
        return;
      }
      Expr _firstExpression = statement.getFirstExpression();
      final Type firstType = CommonUtils.getExpressionType(_firstExpression);
      Expr _secondExpression = statement.getSecondExpression();
      final Type secondType = CommonUtils.getExpressionType(_secondExpression);
      boolean _or_1 = false;
      String _typeName_2 = firstType.getTypeName();
      boolean _equals_3 = Objects.equal(_typeName_2, null);
      if (_equals_3) {
        _or_1 = true;
      } else {
        String _typeName_3 = firstType.getTypeName();
        boolean _equals_4 = _typeName_3.equals("int");
        boolean _not_1 = (!_equals_4);
        _or_1 = _not_1;
      }
      if (_or_1) {
        this.error("Wrong type, should be int", 
          MiniJavaPackage.Literals.STATEMENT__FIRST_EXPRESSION, 
          MiniJavaValidator.NOT_INT);
        return;
      }
      boolean _or_2 = false;
      String _typeName_4 = secondType.getTypeName();
      boolean _equals_5 = Objects.equal(_typeName_4, null);
      if (_equals_5) {
        _or_2 = true;
      } else {
        String _typeName_5 = secondType.getTypeName();
        boolean _equals_6 = _typeName_5.equals("int");
        boolean _not_2 = (!_equals_6);
        _or_2 = _not_2;
      }
      if (_or_2) {
        this.error("Wrong type, should be int", 
          MiniJavaPackage.Literals.STATEMENT__SECOND_EXPRESSION, 
          MiniJavaValidator.NOT_INT);
        return;
      }
    }
  }
  
  @Check(CheckType.FAST)
  public void checkAssignment(final Statement statement) {
    boolean _and = false;
    String _statementType = statement.getStatementType();
    boolean _equals = _statementType.equals("=");
    if (!_equals) {
      _and = false;
    } else {
      boolean _isIsArrayElementAssignment = statement.isIsArrayElementAssignment();
      boolean _not = (!_isIsArrayElementAssignment);
      _and = _not;
    }
    if (_and) {
      Expr _firstExpression = statement.getFirstExpression();
      final Type type = CommonUtils.getExpressionType(_firstExpression);
      boolean _and_1 = false;
      Variable _variable = statement.getVariable();
      Type _variableType = _variable.getVariableType();
      ClassDecl _classDecl = _variableType.getClassDecl();
      boolean _notEquals = (!Objects.equal(_classDecl, null));
      if (!_notEquals) {
        _and_1 = false;
      } else {
        Variable _variable_1 = statement.getVariable();
        Type _variableType_1 = _variable_1.getVariableType();
        ClassDecl _classDecl_1 = _variableType_1.getClassDecl();
        ClassDecl _classDecl_2 = type.getClassDecl();
        boolean _checkCompatibleClassTypes = CommonUtils.checkCompatibleClassTypes(_classDecl_1, _classDecl_2);
        boolean _not_1 = (!_checkCompatibleClassTypes);
        _and_1 = _not_1;
      }
      if (_and_1) {
        this.error("Type mismatch", 
          MiniJavaPackage.Literals.STATEMENT__FIRST_EXPRESSION, 
          MiniJavaValidator.TYPE_MISMATCH);
        return;
      }
      boolean _and_2 = false;
      Variable _variable_2 = statement.getVariable();
      Type _variableType_2 = _variable_2.getVariableType();
      String _typeName = _variableType_2.getTypeName();
      boolean _notEquals_1 = (!Objects.equal(_typeName, null));
      if (!_notEquals_1) {
        _and_2 = false;
      } else {
        boolean _or = false;
        String _typeName_1 = type.getTypeName();
        boolean _equals_1 = Objects.equal(_typeName_1, null);
        if (_equals_1) {
          _or = true;
        } else {
          Variable _variable_3 = statement.getVariable();
          Type _variableType_3 = _variable_3.getVariableType();
          String _typeName_2 = _variableType_3.getTypeName();
          String _typeName_3 = type.getTypeName();
          boolean _equals_2 = _typeName_2.equals(_typeName_3);
          boolean _not_2 = (!_equals_2);
          _or = _not_2;
        }
        _and_2 = _or;
      }
      if (_and_2) {
        this.error("Type mismatch", 
          MiniJavaPackage.Literals.STATEMENT__FIRST_EXPRESSION, 
          MiniJavaValidator.TYPE_MISMATCH);
        return;
      }
    }
  }
  
  @Check(CheckType.FAST)
  public void checkLessParameter(final Expr expression) {
    boolean _and = false;
    String _expressionType = expression.getExpressionType();
    boolean _notEquals = (!Objects.equal(_expressionType, null));
    if (!_notEquals) {
      _and = false;
    } else {
      String _expressionType_1 = expression.getExpressionType();
      boolean _equals = _expressionType_1.equals("&&");
      _and = _equals;
    }
    if (_and) {
      Expr _left = expression.getLeft();
      final Type leftType = CommonUtils.getExpressionType(_left);
      Expr _right = expression.getRight();
      final Type rightType = CommonUtils.getExpressionType(_right);
      boolean _or = false;
      String _typeName = leftType.getTypeName();
      boolean _equals_1 = Objects.equal(_typeName, null);
      if (_equals_1) {
        _or = true;
      } else {
        String _typeName_1 = leftType.getTypeName();
        boolean _equals_2 = _typeName_1.equals("boolean");
        boolean _not = (!_equals_2);
        _or = _not;
      }
      if (_or) {
        this.error("Wrong type, should be boolean", 
          MiniJavaPackage.Literals.EXPR__LEFT, 
          MiniJavaValidator.NOT_BOOLEAN);
        return;
      }
      boolean _or_1 = false;
      String _typeName_2 = rightType.getTypeName();
      boolean _equals_3 = Objects.equal(_typeName_2, null);
      if (_equals_3) {
        _or_1 = true;
      } else {
        String _typeName_3 = rightType.getTypeName();
        boolean _equals_4 = _typeName_3.equals("boolean");
        boolean _not_1 = (!_equals_4);
        _or_1 = _not_1;
      }
      if (_or_1) {
        this.error("Wrong type, should be boolean", 
          MiniJavaPackage.Literals.EXPR__RIGHT, 
          MiniJavaValidator.NOT_BOOLEAN);
        return;
      }
    }
  }
  
  @Check(CheckType.FAST)
  public void checkIntExprParameter(final Expr expression) {
    boolean _and = false;
    String _expressionType = expression.getExpressionType();
    boolean _notEquals = (!Objects.equal(_expressionType, null));
    if (!_notEquals) {
      _and = false;
    } else {
      String _expressionType_1 = expression.getExpressionType();
      boolean _matches = _expressionType_1.matches("<|\\+|-|\\*");
      _and = _matches;
    }
    if (_and) {
      Expr _left = expression.getLeft();
      final Type leftType = CommonUtils.getExpressionType(_left);
      Expr _right = expression.getRight();
      final Type rightType = CommonUtils.getExpressionType(_right);
      boolean _or = false;
      String _typeName = leftType.getTypeName();
      boolean _equals = Objects.equal(_typeName, null);
      if (_equals) {
        _or = true;
      } else {
        String _typeName_1 = leftType.getTypeName();
        boolean _equals_1 = _typeName_1.equals("int");
        boolean _not = (!_equals_1);
        _or = _not;
      }
      if (_or) {
        this.error("Wrong type, should be int", 
          MiniJavaPackage.Literals.EXPR__LEFT, 
          MiniJavaValidator.NOT_INT);
      } else {
        boolean _or_1 = false;
        String _typeName_2 = rightType.getTypeName();
        boolean _equals_2 = Objects.equal(_typeName_2, null);
        if (_equals_2) {
          _or_1 = true;
        } else {
          String _typeName_3 = rightType.getTypeName();
          boolean _equals_3 = _typeName_3.equals("int");
          boolean _not_1 = (!_equals_3);
          _or_1 = _not_1;
        }
        if (_or_1) {
          this.error("Wrong type, should be int", 
            MiniJavaPackage.Literals.EXPR__RIGHT, 
            MiniJavaValidator.NOT_INT);
        }
      }
    }
  }
  
  @Check(CheckType.FAST)
  public void checkNegationParameter(final Expr expression) {
    boolean _and = false;
    String _expressionType = expression.getExpressionType();
    boolean _notEquals = (!Objects.equal(_expressionType, null));
    if (!_notEquals) {
      _and = false;
    } else {
      String _expressionType_1 = expression.getExpressionType();
      boolean _equals = _expressionType_1.equals("!");
      _and = _equals;
    }
    if (_and) {
      Expr _right = expression.getRight();
      final Type type = CommonUtils.getExpressionType(_right);
      boolean _or = false;
      String _typeName = type.getTypeName();
      boolean _equals_1 = Objects.equal(_typeName, null);
      if (_equals_1) {
        _or = true;
      } else {
        String _typeName_1 = type.getTypeName();
        boolean _equals_2 = _typeName_1.equals("boolean");
        boolean _not = (!_equals_2);
        _or = _not;
      }
      if (_or) {
        this.error("Wrong type, should be boolean", 
          MiniJavaPackage.Literals.EXPR__RIGHT, 
          MiniJavaValidator.NOT_BOOLEAN);
      }
    }
  }
  
  @Check(CheckType.FAST)
  public void checkPointExpression(final Expr expression) {
    boolean _and = false;
    String _expressionType = expression.getExpressionType();
    boolean _notEquals = (!Objects.equal(_expressionType, null));
    if (!_notEquals) {
      _and = false;
    } else {
      String _expressionType_1 = expression.getExpressionType();
      boolean _equals = _expressionType_1.equals(".");
      _and = _equals;
    }
    if (_and) {
      Expr _left = expression.getLeft();
      final Type type = CommonUtils.getExpressionType(_left);
      boolean _and_1 = false;
      String _typeName = type.getTypeName();
      boolean _notEquals_1 = (!Objects.equal(_typeName, null));
      if (!_notEquals_1) {
        _and_1 = false;
      } else {
        boolean _or = false;
        boolean _or_1 = false;
        String _typeName_1 = type.getTypeName();
        boolean _equals_1 = _typeName_1.equals("[");
        boolean _not = (!_equals_1);
        if (_not) {
          _or_1 = true;
        } else {
          Expr _right = expression.getRight();
          String _expressionType_2 = _right.getExpressionType();
          boolean _equals_2 = Objects.equal(_expressionType_2, null);
          _or_1 = _equals_2;
        }
        if (_or_1) {
          _or = true;
        } else {
          Expr _right_1 = expression.getRight();
          String _expressionType_3 = _right_1.getExpressionType();
          boolean _equals_3 = _expressionType_3.equals("length");
          boolean _not_1 = (!_equals_3);
          _or = _not_1;
        }
        _and_1 = _or;
      }
      if (_and_1) {
        this.error("Impossible to call method for the expression", 
          MiniJavaPackage.Literals.EXPR__LEFT, 
          MiniJavaValidator.WRONG_METHOD);
      }
      boolean _and_2 = false;
      ClassDecl _classDecl = type.getClassDecl();
      boolean _notEquals_2 = (!Objects.equal(_classDecl, null));
      if (!_notEquals_2) {
        _and_2 = false;
      } else {
        boolean _or_2 = false;
        Expr _right_2 = expression.getRight();
        MethodCall _methodCall = _right_2.getMethodCall();
        boolean _equals_4 = Objects.equal(_methodCall, null);
        if (_equals_4) {
          _or_2 = true;
        } else {
          ClassDecl _classDecl_1 = type.getClassDecl();
          Expr _right_3 = expression.getRight();
          MethodCall _methodCall_1 = _right_3.getMethodCall();
          Method _method = _methodCall_1.getMethod();
          boolean _checkMethodForClass = CommonUtils.checkMethodForClass(_classDecl_1, _method);
          boolean _not_2 = (!_checkMethodForClass);
          _or_2 = _not_2;
        }
        _and_2 = _or_2;
      }
      if (_and_2) {
        this.error("Impossible to call method for the expression", 
          MiniJavaPackage.Literals.EXPR__LEFT, 
          MiniJavaValidator.WRONG_METHOD);
      }
    }
  }
  
  @Check(CheckType.FAST)
  public void checkSquareBracketsExpression(final Expr expression) {
    boolean _and = false;
    String _expressionType = expression.getExpressionType();
    boolean _notEquals = (!Objects.equal(_expressionType, null));
    if (!_notEquals) {
      _and = false;
    } else {
      String _expressionType_1 = expression.getExpressionType();
      boolean _equals = _expressionType_1.equals("[");
      _and = _equals;
    }
    if (_and) {
      Expr _left = expression.getLeft();
      final Type leftType = CommonUtils.getExpressionType(_left);
      Expr _right = expression.getRight();
      final Type rightType = CommonUtils.getExpressionType(_right);
      boolean _or = false;
      String _typeName = leftType.getTypeName();
      boolean _equals_1 = Objects.equal(_typeName, null);
      if (_equals_1) {
        _or = true;
      } else {
        String _typeName_1 = leftType.getTypeName();
        boolean _equals_2 = _typeName_1.equals("[");
        boolean _not = (!_equals_2);
        _or = _not;
      }
      if (_or) {
        this.error("Wrong type, should be int array", 
          MiniJavaPackage.Literals.EXPR__LEFT, 
          MiniJavaValidator.NOT_ARRAY);
        return;
      }
      boolean _or_1 = false;
      String _typeName_2 = rightType.getTypeName();
      boolean _equals_3 = Objects.equal(_typeName_2, null);
      if (_equals_3) {
        _or_1 = true;
      } else {
        String _typeName_3 = rightType.getTypeName();
        boolean _equals_4 = _typeName_3.equals("int");
        boolean _not_1 = (!_equals_4);
        _or_1 = _not_1;
      }
      if (_or_1) {
        this.error("Wrong type, should be int", 
          MiniJavaPackage.Literals.EXPR__RIGHT, 
          MiniJavaValidator.NOT_INT);
        return;
      }
    }
  }
  
  @Check(CheckType.FAST)
  public void checkNewArrayParameter(final Expr expression) {
    boolean _and = false;
    boolean _and_1 = false;
    String _expressionType = expression.getExpressionType();
    boolean _notEquals = (!Objects.equal(_expressionType, null));
    if (!_notEquals) {
      _and_1 = false;
    } else {
      String _expressionType_1 = expression.getExpressionType();
      boolean _equals = _expressionType_1.equals("new");
      _and_1 = _equals;
    }
    if (!_and_1) {
      _and = false;
    } else {
      Type _type = expression.getType();
      boolean _equals_1 = Objects.equal(_type, null);
      _and = _equals_1;
    }
    if (_and) {
      Expr _expression = expression.getExpression();
      final Type type = CommonUtils.getExpressionType(_expression);
      boolean _or = false;
      String _typeName = type.getTypeName();
      boolean _equals_2 = Objects.equal(_typeName, null);
      if (_equals_2) {
        _or = true;
      } else {
        String _typeName_1 = type.getTypeName();
        boolean _equals_3 = _typeName_1.equals("int");
        boolean _not = (!_equals_3);
        _or = _not;
      }
      if (_or) {
        this.error("Wrong type, should be int", 
          MiniJavaPackage.Literals.EXPR__EXPRESSION, 
          MiniJavaValidator.NOT_INT);
      }
    }
  }
  
  @Check(CheckType.FAST)
  public void checkNewPrimitiveTypeExpression(final Expr expression) {
    boolean _and = false;
    boolean _and_1 = false;
    String _expressionType = expression.getExpressionType();
    boolean _notEquals = (!Objects.equal(_expressionType, null));
    if (!_notEquals) {
      _and_1 = false;
    } else {
      String _expressionType_1 = expression.getExpressionType();
      boolean _equals = _expressionType_1.equals("new");
      _and_1 = _equals;
    }
    if (!_and_1) {
      _and = false;
    } else {
      Type _type = expression.getType();
      boolean _notEquals_1 = (!Objects.equal(_type, null));
      _and = _notEquals_1;
    }
    if (_and) {
      Type _type_1 = expression.getType();
      String _typeName = _type_1.getTypeName();
      boolean _notEquals_2 = (!Objects.equal(_typeName, null));
      if (_notEquals_2) {
        this.error("Wrong type, should be int", 
          MiniJavaPackage.Literals.EXPR__TYPE, 
          MiniJavaValidator.WRONG_INSTANTIATION);
      }
    }
  }
}
