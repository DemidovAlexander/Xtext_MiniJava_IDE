/**
 * generated by Xtext 2.9.1
 */
package demidov.projects.scoping;

import com.google.common.base.Objects;
import com.google.common.base.Predicate;
import demidov.projects.miniJava.ClassDecl;
import demidov.projects.miniJava.Expr;
import demidov.projects.miniJava.Method;
import demidov.projects.miniJava.MethodCall;
import demidov.projects.miniJava.MiniJavaPackage;
import demidov.projects.miniJava.Point;
import demidov.projects.miniJava.Statement;
import demidov.projects.miniJava.Type;
import demidov.projects.miniJava.VarDeclaration;
import demidov.projects.miniJava.Variable;
import demidov.projects.scoping.AbstractMiniJavaScopeProvider;
import demidov.projects.utils.CommonUtils;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.FilteringScope;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class MiniJavaScopeProvider extends AbstractMiniJavaScopeProvider {
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    boolean _and = false;
    if (!(context instanceof ClassDecl)) {
      _and = false;
    } else {
      boolean _equals = Objects.equal(reference, MiniJavaPackage.Literals.CLASS_DECL__EXTENDED_CLASS);
      _and = _equals;
    }
    if (_and) {
      final EObject rootElement = EcoreUtil2.getRootContainer(context);
      final List<ClassDecl> candidates = EcoreUtil2.<ClassDecl>getAllContentsOfType(rootElement, ClassDecl.class);
      final IScope existingScope = Scopes.scopeFor(candidates);
      final FilteringScope filteredScope = new FilteringScope(existingScope, new Predicate<IEObjectDescription>() {
        @Override
        public boolean apply(final IEObjectDescription input) {
          EObject _eObjectOrProxy = input.getEObjectOrProxy();
          return (!Objects.equal(_eObjectOrProxy, context));
        }
      });
      return filteredScope;
    }
    boolean _and_1 = false;
    if (!(context instanceof MethodCall)) {
      _and_1 = false;
    } else {
      boolean _equals_1 = Objects.equal(reference, MiniJavaPackage.Literals.METHOD_CALL__METHOD);
      _and_1 = _equals_1;
    }
    if (_and_1) {
      final Point pointExpression = EcoreUtil2.<Point>getContainerOfType(context, Point.class);
      Expr _left = pointExpression.getLeft();
      Type _expressionType = CommonUtils.getExpressionType(_left);
      final ClassDecl classDecl = _expressionType.getClassDecl();
      HashSet<Method> _methodsForClass = CommonUtils.getMethodsForClass(classDecl);
      return Scopes.scopeFor(_methodsForClass);
    }
    boolean _or = false;
    boolean _and_2 = false;
    if (!(context instanceof Statement)) {
      _and_2 = false;
    } else {
      boolean _equals_2 = Objects.equal(reference, MiniJavaPackage.Literals.STATEMENT__VARIABLE);
      _and_2 = _equals_2;
    }
    if (_and_2) {
      _or = true;
    } else {
      boolean _and_3 = false;
      if (!(context instanceof Expr)) {
        _and_3 = false;
      } else {
        boolean _equals_3 = Objects.equal(reference, MiniJavaPackage.Literals.EXPR__VARIABLE);
        _and_3 = _equals_3;
      }
      _or = _and_3;
    }
    if (_or) {
      HashSet<String> variablesNames = new HashSet<String>();
      ArrayList<Variable> variablesCandidates = new ArrayList<Variable>();
      final Method method = EcoreUtil2.<Method>getContainerOfType(context, Method.class);
      ClassDecl classDecl_1 = EcoreUtil2.<ClassDecl>getContainerOfType(context, ClassDecl.class);
      boolean _and_4 = false;
      boolean _notEquals = (!Objects.equal(method, null));
      if (!_notEquals) {
        _and_4 = false;
      } else {
        EList<Method> _methodDeclarations = classDecl_1.getMethodDeclarations();
        boolean _contains = _methodDeclarations.contains(method);
        _and_4 = _contains;
      }
      if (_and_4) {
        EList<Variable> _formalVarDeclarations = method.getFormalVarDeclarations();
        variablesCandidates.addAll(_formalVarDeclarations);
        EList<VarDeclaration> _localVarDeclarations = method.getLocalVarDeclarations();
        for (final VarDeclaration varDeclaration : _localVarDeclarations) {
          Variable _variable = varDeclaration.getVariable();
          variablesCandidates.add(_variable);
        }
      }
      for (final Variable variablesCandidate : variablesCandidates) {
        String _name = variablesCandidate.getName();
        variablesNames.add(_name);
      }
      do {
        {
          EList<VarDeclaration> _varDeclarations = classDecl_1.getVarDeclarations();
          for (final VarDeclaration varDeclaration_1 : _varDeclarations) {
            {
              final Variable variable = varDeclaration_1.getVariable();
              String _name_1 = variable.getName();
              boolean _contains_1 = variablesNames.contains(_name_1);
              boolean _not = (!_contains_1);
              if (_not) {
                String _name_2 = variable.getName();
                variablesNames.add(_name_2);
                variablesCandidates.add(variable);
              }
            }
          }
          ClassDecl _extendedClass = classDecl_1.getExtendedClass();
          classDecl_1 = _extendedClass;
        }
      } while((!Objects.equal(classDecl_1, null)));
      final IScope scope = Scopes.scopeFor(variablesCandidates);
      return scope;
    }
    return super.getScope(context, reference);
  }
}
