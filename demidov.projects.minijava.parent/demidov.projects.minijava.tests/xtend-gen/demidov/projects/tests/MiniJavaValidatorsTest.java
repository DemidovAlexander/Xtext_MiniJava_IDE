/**
 * generated by Xtext 2.9.1
 */
package demidov.projects.tests;

import com.google.inject.Inject;
import com.google.inject.Injector;
import demidov.projects.MiniJavaStandaloneSetup;
import demidov.projects.miniJava.ClassDecl;
import demidov.projects.miniJava.Expr;
import demidov.projects.miniJava.Method;
import demidov.projects.miniJava.MethodCall;
import demidov.projects.miniJava.MiniJavaFactory;
import demidov.projects.miniJava.Program;
import demidov.projects.miniJava.Statement;
import demidov.projects.miniJava.VarDeclaration;
import demidov.projects.miniJava.Variable;
import demidov.projects.tests.MiniJavaInjectorProvider;
import demidov.projects.validation.MiniJavaValidator;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.junit4.AbstractXtextTests;
import org.eclipse.xtext.junit4.InjectWith;
import org.eclipse.xtext.junit4.XtextRunner;
import org.eclipse.xtext.junit4.util.ParseHelper;
import org.eclipse.xtext.junit4.validation.AssertableDiagnostics;
import org.eclipse.xtext.junit4.validation.ValidatorTester;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function0;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(XtextRunner.class)
@InjectWith(MiniJavaInjectorProvider.class)
@SuppressWarnings("all")
public class MiniJavaValidatorsTest extends AbstractXtextTests {
  public final static String MAIN_CLASS_CODE = new Function0<String>() {
    public String apply() {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class MainClass {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("public static void main(String[] a) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("System.out.println(0);");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("} ");
      _builder.newLine();
      return _builder.toString();
    }
  }.apply();
  
  @Inject
  private ParseHelper<Program> parser;
  
  private ValidatorTester<MiniJavaValidator> tester;
  
  @Before
  public void setUpTesting() {
    try {
      this.with(MiniJavaStandaloneSetup.class);
      final MiniJavaValidator validator = this.<MiniJavaValidator>get(MiniJavaValidator.class);
      Injector _injector = this.getInjector();
      ValidatorTester<MiniJavaValidator> _validatorTester = new ValidatorTester<MiniJavaValidator>(validator, _injector);
      this.tester = _validatorTester;
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testClassNameChecking() {
    final ClassDecl classDeclaration = MiniJavaFactory.eINSTANCE.createClassDecl();
    classDeclaration.setName("bar");
    MiniJavaValidator _validator = this.tester.validator();
    _validator.checkClassName(classDeclaration);
    AssertableDiagnostics _diagnose = this.tester.diagnose();
    _diagnose.assertWarningContains("Name should start with a capital");
  }
  
  @Test
  public void testCyclicDependanceChecking() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A extends B {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B extends A {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      MiniJavaValidator _validator = this.tester.validator();
      EList<ClassDecl> _classDeclarations = model.getClassDeclarations();
      ClassDecl _get = _classDeclarations.get(1);
      _validator.checkCyclicDependance(_get);
      AssertableDiagnostics _diagnose = this.tester.diagnose();
      _diagnose.assertError("cyclicDependence");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testDuplicateClassNamesChecking() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      EList<ClassDecl> _classDeclarations = model.getClassDeclarations();
      final ClassDecl classDecl = _classDeclarations.get(1);
      MiniJavaValidator _validator = this.tester.validator();
      _validator.checkDuplicateClassNames(classDecl);
      AssertableDiagnostics _diagnose = this.tester.diagnose();
      _diagnose.assertError("duplicateNames");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testDuplicateClassVariablesNamesChecking() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {\t\t\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("int a;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("boolean a;");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      EList<ClassDecl> _classDeclarations = model.getClassDeclarations();
      final ClassDecl classDecl = _classDeclarations.get(1);
      MiniJavaValidator _validator = this.tester.validator();
      EList<VarDeclaration> _varDeclarations = classDecl.getVarDeclarations();
      VarDeclaration _get = _varDeclarations.get(0);
      Variable _variable = _get.getVariable();
      _validator.checkDuplicateVariablesNames(_variable);
      AssertableDiagnostics _diagnose = this.tester.diagnose();
      _diagnose.assertError("duplicateNames");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testDuplicateMethodVariablesNamesChecking1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {\t\t\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("B a;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      EList<ClassDecl> _classDeclarations = model.getClassDeclarations();
      ClassDecl _get = _classDeclarations.get(1);
      EList<Method> _methodDeclarations = _get.getMethodDeclarations();
      final Method method = _methodDeclarations.get(0);
      MiniJavaValidator _validator = this.tester.validator();
      EList<VarDeclaration> _localVarDeclarations = method.getLocalVarDeclarations();
      VarDeclaration _get_1 = _localVarDeclarations.get(0);
      Variable _variable = _get_1.getVariable();
      _validator.checkDuplicateVariablesNames(_variable);
      AssertableDiagnostics _diagnose = this.tester.diagnose();
      _diagnose.assertError("duplicateNames");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testDuplicateMethodVariablesNamesChecking2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {\t\t\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method(int a) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("B a;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      EList<ClassDecl> _classDeclarations = model.getClassDeclarations();
      ClassDecl _get = _classDeclarations.get(1);
      EList<Method> _methodDeclarations = _get.getMethodDeclarations();
      final Method method = _methodDeclarations.get(0);
      MiniJavaValidator _validator = this.tester.validator();
      EList<Variable> _formalVarDeclarations = method.getFormalVarDeclarations();
      Variable _get_1 = _formalVarDeclarations.get(0);
      _validator.checkDuplicateVariablesNames(_get_1);
      AssertableDiagnostics _diagnose = this.tester.diagnose();
      _diagnose.assertError("duplicateNames");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testMethodParametersChecking1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method(int bar) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int use() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("A a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int b;");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("b = a.method();");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}\t\t\t\t\t\t\t\t\t\t");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      EList<ClassDecl> _classDeclarations = model.getClassDeclarations();
      ClassDecl _get = _classDeclarations.get(2);
      EList<Method> _methodDeclarations = _get.getMethodDeclarations();
      Method _get_1 = _methodDeclarations.get(0);
      EList<Statement> _statements = _get_1.getStatements();
      final Statement statement = _statements.get(0);
      MiniJavaValidator _validator = this.tester.validator();
      Expr _firstExpression = statement.getFirstExpression();
      Expr _right = _firstExpression.getRight();
      MethodCall _methodCall = _right.getMethodCall();
      _validator.checkMethodParameters(_methodCall);
      AssertableDiagnostics _diagnose = this.tester.diagnose();
      _diagnose.assertError("wrongParameters");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testMethodParametersChecking2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method(int bar) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int use() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("A a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int c;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int d;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("b = a.method(c, d);");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}\t\t\t\t\t\t\t\t\t\t");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      EList<ClassDecl> _classDeclarations = model.getClassDeclarations();
      ClassDecl _get = _classDeclarations.get(2);
      EList<Method> _methodDeclarations = _get.getMethodDeclarations();
      Method _get_1 = _methodDeclarations.get(0);
      EList<Statement> _statements = _get_1.getStatements();
      final Statement statement = _statements.get(0);
      MiniJavaValidator _validator = this.tester.validator();
      Expr _firstExpression = statement.getFirstExpression();
      Expr _right = _firstExpression.getRight();
      MethodCall _methodCall = _right.getMethodCall();
      _validator.checkMethodParameters(_methodCall);
      AssertableDiagnostics _diagnose = this.tester.diagnose();
      _diagnose.assertError("wrongParameters");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testMethodParametersChecking3() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {\t\t\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method(int bar, C foo) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int use() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("A a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("C c;");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("b = a.method(b, b);");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}\t\t\t\t\t\t\t\t\t");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class C {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      EList<ClassDecl> _classDeclarations = model.getClassDeclarations();
      ClassDecl _get = _classDeclarations.get(2);
      EList<Method> _methodDeclarations = _get.getMethodDeclarations();
      Method _get_1 = _methodDeclarations.get(0);
      EList<Statement> _statements = _get_1.getStatements();
      final Statement statement = _statements.get(0);
      MiniJavaValidator _validator = this.tester.validator();
      Expr _firstExpression = statement.getFirstExpression();
      Expr _right = _firstExpression.getRight();
      MethodCall _methodCall = _right.getMethodCall();
      _validator.checkMethodParameters(_methodCall);
      AssertableDiagnostics _diagnose = this.tester.diagnose();
      _diagnose.assertError("typeMismatch");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testMethodParametersChecking4() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {\t\t\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method(int bar, C foo) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int use() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("A a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("C c;");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("b = a.method(b, a);");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}\t\t\t\t\t\t\t\t\t\t");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class C {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      EList<ClassDecl> _classDeclarations = model.getClassDeclarations();
      ClassDecl _get = _classDeclarations.get(2);
      EList<Method> _methodDeclarations = _get.getMethodDeclarations();
      Method _get_1 = _methodDeclarations.get(0);
      EList<Statement> _statements = _get_1.getStatements();
      final Statement statement = _statements.get(0);
      MiniJavaValidator _validator = this.tester.validator();
      Expr _firstExpression = statement.getFirstExpression();
      Expr _right = _firstExpression.getRight();
      MethodCall _methodCall = _right.getMethodCall();
      _validator.checkMethodParameters(_methodCall);
      AssertableDiagnostics _diagnose = this.tester.diagnose();
      _diagnose.assertError("typeMismatch");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testMethodParametersChecking5() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {\t\t\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method(int bar, C foo) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int use() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("A a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("C c;");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("b = a.method(c, c);");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}\t\t\t\t\t\t\t\t\t\t");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class C {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      EList<ClassDecl> _classDeclarations = model.getClassDeclarations();
      ClassDecl _get = _classDeclarations.get(2);
      EList<Method> _methodDeclarations = _get.getMethodDeclarations();
      Method _get_1 = _methodDeclarations.get(0);
      EList<Statement> _statements = _get_1.getStatements();
      final Statement statement = _statements.get(0);
      MiniJavaValidator _validator = this.tester.validator();
      Expr _firstExpression = statement.getFirstExpression();
      Expr _right = _firstExpression.getRight();
      MethodCall _methodCall = _right.getMethodCall();
      _validator.checkMethodParameters(_methodCall);
      AssertableDiagnostics _diagnose = this.tester.diagnose();
      _diagnose.assertError("typeMismatch");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testReturnExpressionChecking1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {\t\t\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method(int bar) {\t\t\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return false;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("wrongReturn");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testReturnExpressionChecking2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {\t\t\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method(int bar) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("B b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return b;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B extends A {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("wrongReturn");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testReturnExpressionChecking3() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {\t\t\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public B method(int bar) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("boolean b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return b;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("wrongReturn");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testConditionParameterChecking1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (a) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("returns 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("notBoolean");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testConditionParameterChecking2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("B b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("while (b) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("returns 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("notBoolean");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testPrintlnParameterChecking1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int[] a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("System.out.println(a);");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("notInt");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testPrintlnParameterChecking2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("B b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("System.out.println(b);");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("notInt");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testArrayElementAssignmentChecking1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int c;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("b[2] = \tc;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("notArray");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testArrayElementAssignmentChecking2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int[] b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("boolean c;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("b[2] = \tc;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("notInt");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testArrayElementAssignmentChecking3() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int[] b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("boolean c;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int d;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("b[c] = \td;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("notInt");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testAssignmentChecking1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("boolean b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("typeMismatch");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testAssignmentChecking2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("B b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("typeMismatch");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testAssignmentChecking3() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("B b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("C c;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("b = c;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class C {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("typeMismatch");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testLessParameterChecking1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("boolean a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("boolean b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int c;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = b && c;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("notBoolean");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testLessParameterChecking2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("boolean a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("B b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("boolean c;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = b && c;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("notBoolean");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testIntExprParameterChecking1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("boolean b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = a < b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      EList<ClassDecl> _classDeclarations = model.getClassDeclarations();
      ClassDecl _get = _classDeclarations.get(1);
      EList<Method> _methodDeclarations = _get.getMethodDeclarations();
      Method _get_1 = _methodDeclarations.get(0);
      EList<Statement> _statements = _get_1.getStatements();
      final Statement statement = _statements.get(0);
      MiniJavaValidator _validator = this.tester.validator();
      Expr _firstExpression = statement.getFirstExpression();
      _validator.checkIntExprParameter(_firstExpression);
      AssertableDiagnostics _diagnose = this.tester.diagnose();
      _diagnose.assertError("notInt");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testIntExprParameterChecking2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("B b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = a + b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      EList<ClassDecl> _classDeclarations = model.getClassDeclarations();
      ClassDecl _get = _classDeclarations.get(1);
      EList<Method> _methodDeclarations = _get.getMethodDeclarations();
      Method _get_1 = _methodDeclarations.get(0);
      EList<Statement> _statements = _get_1.getStatements();
      final Statement statement = _statements.get(0);
      MiniJavaValidator _validator = this.tester.validator();
      Expr _firstExpression = statement.getFirstExpression();
      _validator.checkIntExprParameter(_firstExpression);
      AssertableDiagnostics _diagnose = this.tester.diagnose();
      _diagnose.assertError("notInt");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testIntExprParameterChecking3() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("B b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("C c;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = b * c;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class C {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      EList<ClassDecl> _classDeclarations = model.getClassDeclarations();
      ClassDecl _get = _classDeclarations.get(1);
      EList<Method> _methodDeclarations = _get.getMethodDeclarations();
      Method _get_1 = _methodDeclarations.get(0);
      EList<Statement> _statements = _get_1.getStatements();
      final Statement statement = _statements.get(0);
      MiniJavaValidator _validator = this.tester.validator();
      Expr _firstExpression = statement.getFirstExpression();
      _validator.checkIntExprParameter(_firstExpression);
      AssertableDiagnostics _diagnose = this.tester.diagnose();
      _diagnose.assertError("notInt");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testNegationParameterChecking1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("boolean a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = !b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("notBoolean");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testNegationParameterChecking2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("boolean a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("B b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = !b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("notBoolean");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testPointExpressionChecking1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = b.length;\t\t\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("wrongMethod");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testPointExpressionChecking2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("B b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = b.length;\t\t\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("wrongMethod");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testPointExpressionChecking3() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int[] b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = b.(length);\t\t\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("wrongMethod");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testPointExpressionChecking4() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int[] b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = b.length;\t\t\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertOK();
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testPointExpressionChecking5() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("b a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = b.check();\t\t\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public boolean check() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return true;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("wrongMethod");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testPointExpressionChecking6() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("B b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = b.method();\t\t\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public boolean check() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return true;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("wrongMethod");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testPointExpressionChecking7() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("boolean a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("B b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = b.check();\t\t\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public boolean check() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return true;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertOK();
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testSquareBracketsExpressionChecking() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int c;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = b[c];");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("notArray");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testSquareBracketsExpressionChecking2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("B b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int c;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = b[c];");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("notArray");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testSquareBracketsExpressionChecking3() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int[] b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("boolean c;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = b[c];");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("notInt");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testSquareBracketsExpressionChecking4() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int[] b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("B c;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = b[c];");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertError("notInt");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testNewArrayParameterChecking1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int[] a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("boolean b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = new int[b];");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      EList<ClassDecl> _classDeclarations = model.getClassDeclarations();
      ClassDecl _get = _classDeclarations.get(1);
      EList<Method> _methodDeclarations = _get.getMethodDeclarations();
      Method _get_1 = _methodDeclarations.get(0);
      EList<Statement> _statements = _get_1.getStatements();
      final Statement statement = _statements.get(0);
      MiniJavaValidator _validator = this.tester.validator();
      Expr _firstExpression = statement.getFirstExpression();
      _validator.checkNewArrayParameter(_firstExpression);
      AssertableDiagnostics _diagnose = this.tester.diagnose();
      _diagnose.assertError("notInt");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testNewArrayParameterChecking2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int[] a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("B b;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = new int[b];");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class B {");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      EList<ClassDecl> _classDeclarations = model.getClassDeclarations();
      ClassDecl _get = _classDeclarations.get(1);
      EList<Method> _methodDeclarations = _get.getMethodDeclarations();
      Method _get_1 = _methodDeclarations.get(0);
      EList<Statement> _statements = _get_1.getStatements();
      final Statement statement = _statements.get(0);
      MiniJavaValidator _validator = this.tester.validator();
      Expr _firstExpression = statement.getFirstExpression();
      _validator.checkNewArrayParameter(_firstExpression);
      AssertableDiagnostics _diagnose = this.tester.diagnose();
      _diagnose.assertError("notInt");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testNewPrimitiveTypeExpressionChecking() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("class A {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("public int method() {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("int a;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("a = new int();");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      String _plus = (MiniJavaValidatorsTest.MAIN_CLASS_CODE + _builder);
      final Program model = this.parser.parse(_plus);
      EList<ClassDecl> _classDeclarations = model.getClassDeclarations();
      ClassDecl _get = _classDeclarations.get(1);
      EList<Method> _methodDeclarations = _get.getMethodDeclarations();
      Method _get_1 = _methodDeclarations.get(0);
      EList<Statement> _statements = _get_1.getStatements();
      final Statement statement = _statements.get(0);
      MiniJavaValidator _validator = this.tester.validator();
      Expr _firstExpression = statement.getFirstExpression();
      _validator.checkNewPrimitiveTypeExpression(_firstExpression);
      AssertableDiagnostics _diagnose = this.tester.diagnose();
      _diagnose.assertError("wrongInstantiation");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
}
