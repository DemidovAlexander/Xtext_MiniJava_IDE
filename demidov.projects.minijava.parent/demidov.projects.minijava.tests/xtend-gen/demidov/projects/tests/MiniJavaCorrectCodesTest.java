/**
 * generated by Xtext 2.9.1
 */
package demidov.projects.tests;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import com.google.inject.Injector;
import demidov.projects.MiniJavaStandaloneSetup;
import demidov.projects.miniJava.Program;
import demidov.projects.tests.MiniJavaInjectorProvider;
import demidov.projects.validation.MiniJavaValidator;
import java.io.BufferedReader;
import java.io.FileReader;
import org.eclipse.xtext.junit4.AbstractXtextTests;
import org.eclipse.xtext.junit4.InjectWith;
import org.eclipse.xtext.junit4.XtextRunner;
import org.eclipse.xtext.junit4.util.ParseHelper;
import org.eclipse.xtext.junit4.validation.AssertableDiagnostics;
import org.eclipse.xtext.junit4.validation.ValidatorTester;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(XtextRunner.class)
@InjectWith(MiniJavaInjectorProvider.class)
@SuppressWarnings("all")
public class MiniJavaCorrectCodesTest extends AbstractXtextTests {
  @Inject
  private ParseHelper<Program> parser;
  
  private ValidatorTester<MiniJavaValidator> tester;
  
  public String readSourceFile(final String fileName) {
    try {
      StringBuilder text = new StringBuilder();
      FileReader _fileReader = new FileReader(fileName);
      BufferedReader bufferedReader = new BufferedReader(_fileReader);
      String line = bufferedReader.readLine();
      final String newline = System.getProperty("line.separator");
      while ((!Objects.equal(line, null))) {
        {
          text.append((line + newline));
          String _readLine = bufferedReader.readLine();
          line = _readLine;
        }
      }
      return text.toString();
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Before
  public void setUpTesting() {
    try {
      this.with(MiniJavaStandaloneSetup.class);
      final MiniJavaValidator validator = this.<MiniJavaValidator>get(MiniJavaValidator.class);
      Injector _injector = this.getInjector();
      ValidatorTester<MiniJavaValidator> _validatorTester = new ValidatorTester<MiniJavaValidator>(validator, _injector);
      this.tester = _validatorTester;
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testCorrectFactorialCode() {
    try {
      String _readSourceFile = this.readSourceFile(".\\src\\demidov\\projects\\tests\\Factorial.mj");
      final Program model = this.parser.parse(_readSourceFile);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertOK();
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testCorrectBinarySearchCode() {
    try {
      String _readSourceFile = this.readSourceFile(".\\src\\demidov\\projects\\tests\\BinarySearch.mj");
      final Program model = this.parser.parse(_readSourceFile);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertOK();
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testCorrectBubbleSortCode() {
    try {
      String _readSourceFile = this.readSourceFile(".\\src\\demidov\\projects\\tests\\BubbleSort.mj");
      final Program model = this.parser.parse(_readSourceFile);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertOK();
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testCorrectTreeVisitorCode() {
    try {
      String _readSourceFile = this.readSourceFile(".\\src\\demidov\\projects\\tests\\TreeVisitor.mj");
      final Program model = this.parser.parse(_readSourceFile);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertOK();
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testCorrectQuickSortCode() {
    try {
      String _readSourceFile = this.readSourceFile(".\\src\\demidov\\projects\\tests\\QuickSort.mj");
      final Program model = this.parser.parse(_readSourceFile);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertOK();
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testCorrectLinearSearchCode() {
    try {
      String _readSourceFile = this.readSourceFile(".\\src\\demidov\\projects\\tests\\LinearSearch.mj");
      final Program model = this.parser.parse(_readSourceFile);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertOK();
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testCorrectLinkedListCode() {
    try {
      String _readSourceFile = this.readSourceFile(".\\src\\demidov\\projects\\tests\\LinkedList.mj");
      final Program model = this.parser.parse(_readSourceFile);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertOK();
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testCorrectBinaryTreeCode() {
    try {
      String _readSourceFile = this.readSourceFile(".\\src\\demidov\\projects\\tests\\BinaryTree.mj");
      final Program model = this.parser.parse(_readSourceFile);
      AssertableDiagnostics _validate = this.tester.validate(model);
      _validate.assertOK();
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
}
