/*
 * generated by Xtext 2.9.1
 */
package demidov.projects.tests

import com.google.inject.Inject
import demidov.projects.miniJava.Program
import org.eclipse.xtext.junit4.InjectWith
import org.eclipse.xtext.junit4.XtextRunner
import org.eclipse.xtext.junit4.util.ParseHelper
import org.junit.Test
import org.junit.runner.RunWith
import org.eclipse.xtext.junit4.validation.ValidatorTester
import org.eclipse.xtext.junit4.AbstractXtextTests
import demidov.projects.validation.MiniJavaValidator
import demidov.projects.miniJava.MiniJavaFactory
import org.junit.Before
import demidov.projects.MiniJavaStandaloneSetup

@RunWith(XtextRunner)
@InjectWith(MiniJavaInjectorProvider)
public class MiniJavaValidatorsTest extends AbstractXtextTests {
	
	public static val MAIN_CLASS_CODE = '''class MainClass {
		public static void main(String[] a) {
			System.out.println(0);
		}
	} 
	'''		
	@Inject
	ParseHelper<Program> parser;

	ValidatorTester<MiniJavaValidator> tester;
		
	@Before
	def void setUpTesting() {
		with(MiniJavaStandaloneSetup);
		val validator = get(MiniJavaValidator);
		tester = new ValidatorTester<MiniJavaValidator>(validator, getInjector());
  	}
  	
  	// Validators testing	
	
	@Test
	def testClassNameChecking() {
		val classDeclaration = MiniJavaFactory.eINSTANCE.createClassDecl()
		classDeclaration.setName('bar');
 
		tester.validator().checkClassName(classDeclaration);
		tester.diagnose().assertWarningContains('Name should start with a capital');

	}
	
	// Cyclic dependance		
	@Test
	def testCyclicDependanceChecking() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A extends B {
			}
			
			class B extends A {
			}
		 ''');
 		 
		tester.validator().checkCyclicDependance(model.classDeclarations.get(1));
		tester.diagnose().assertError('cyclicDependence');
	}
	
	// Duplicate names of the classes
	@Test
	def testDuplicateClassNamesChecking() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
			}
			
			class A {
			}
		''');
 
		val classDecl = model.classDeclarations.get(1);
		
 		tester.validator().checkDuplicateClassNames(classDecl);
		tester.diagnose().assertError('duplicateNames');
	}
	
	// Duplicate names of the variables
	@Test
	def testDuplicateClassVariablesNamesChecking() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {			
				int a;
				boolean a;
			}
		''');
 
		val classDecl = model.classDeclarations.get(1);
		
 		tester.validator().checkDuplicateVariablesNames(classDecl.varDeclarations.get(0).variable);
		tester.diagnose().assertError('duplicateNames');
	}
	
	@Test
	def testDuplicateMethodVariablesNamesChecking1() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {			
				public int method() {
					int a;
					B a;

					return 0;
				}
			}
			
			class B {
			}
		''');
 
		val method = model.classDeclarations.get(1).methodDeclarations.get(0);
		
 		tester.validator().checkDuplicateVariablesNames(method.localVarDeclarations.get(0).variable);
		tester.diagnose().assertError('duplicateNames');
	}
	
	@Test
	def testDuplicateMethodVariablesNamesChecking2() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {			
				public int method(int a) {
					B a;

					return 0;
				}
			}
			
			class B {
			}
		''');
 
		val method = model.classDeclarations.get(1).methodDeclarations.get(0);
		
 		tester.validator().checkDuplicateVariablesNames(method.formalVarDeclarations.get(0));
		tester.diagnose().assertError('duplicateNames');
	}
	
	// Wrong method parameters
	@Test
	def testMethodParametersChecking1() {
		val model = parser.parse(MAIN_CLASS_CODE + '''		
			class A {
				public int method(int bar) {
					return 0;
				}
			}
			
			class B {
				public int use() {
					A a;
					int b;
				
					b = a.method();
					return 0;
				}										
			}
		''');
		
		val statement = model.classDeclarations.get(2).methodDeclarations.get(0).statements.get(0);
		 
		tester.validator().checkMethodParameters(statement.firstExpression.right.methodCall);
		tester.diagnose().assertError('wrongParameters');
	}
	
	@Test
	def testMethodParametersChecking2() {
		val model = parser.parse(MAIN_CLASS_CODE + '''		
			class A {
				public int method(int bar) {
					return 0;
				}
			}
			
			class B {
				public int use() {
					A a;
					int b;
					int c;
					int d;
					
					b = a.method(c, d);
					return 0;
				}										
			}
		''');
 
		val statement = model.classDeclarations.get(2).methodDeclarations.get(0).statements.get(0);
		 
		tester.validator().checkMethodParameters(statement.firstExpression.right.methodCall);
		tester.diagnose().assertError('wrongParameters');
	}
	
	@Test
	def testMethodParametersChecking3() {
		val model = parser.parse(MAIN_CLASS_CODE + '''		
			class A {			
				public int method(int bar, C foo) {
					return 0;
				}
			}
			
			class B {
				public int use() {
					A a;
					int b;
					C c;
				
					b = a.method(b, b);
					
					return 0;
				}									
			}
			
			class C {
			}
		''');

		val statement = model.classDeclarations.get(2).methodDeclarations.get(0).statements.get(0);
		 
		tester.validator().checkMethodParameters(statement.firstExpression.right.methodCall);
		tester.diagnose().assertError('typeMismatch');
	}
	
	@Test
	def testMethodParametersChecking4() {
		val model = parser.parse(MAIN_CLASS_CODE + '''		
			class A {			
				public int method(int bar, C foo) {
					return 0;
				}
			}
			
			class B {
				public int use() {
					A a;
					int b;
					C c;
				
					b = a.method(b, a);
					
					return 0;
				}										
			}
			
			class C {
			}
		''');
 
		val statement = model.classDeclarations.get(2).methodDeclarations.get(0).statements.get(0);
		 
		tester.validator().checkMethodParameters(statement.firstExpression.right.methodCall);
		tester.diagnose().assertError('typeMismatch');
	}
	
	@Test
	def testMethodParametersChecking5() {
		val model = parser.parse(MAIN_CLASS_CODE + '''		
			class A {			
				public int method(int bar, C foo) {
					return 0;
				}
			}
			
			class B {
				public int use() {
					A a;
					int b;
					C c;
				
					b = a.method(c, c);
				
					return 0;
				}										
			}
			
			class C {
			}
		''');
 
		val statement = model.classDeclarations.get(2).methodDeclarations.get(0).statements.get(0);
		 
		tester.validator().checkMethodParameters(statement.firstExpression.right.methodCall);
		tester.diagnose().assertError('typeMismatch');
	}
		
	// Wrong type of the return expression
	@Test
	def testReturnExpressionChecking1() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {			
				public int method(int bar) {				
					return false;
				}
			}
		''');
		
		tester.validate(model).assertError('wrongReturn');
	}
	
	@Test
	def testReturnExpressionChecking2() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {			
				public int method(int bar) {
					B b;
					return b;
				}
			}
			
			class B extends A {
			}
		''');
 
		tester.validate(model).assertError('wrongReturn');
	}
	
	@Test
	def testReturnExpressionChecking3() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {			
				public B method(int bar) {
					boolean b;
					return b;
				}
			}
			
			class B {
			}
		''');
 
		tester.validate(model).assertError('wrongReturn');
	}
	
	// Wrong type in condition
	@Test
	def testConditionParameterChecking1() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int a;
					
					if (a) {
					}
					
					returns 0;
				}
			}
		''');
 
		tester.validate(model).assertError('notBoolean');
	}
	
	@Test
	def testConditionParameterChecking2() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					B b;
					
					while (b) {
					}
					
					returns 0;
				}
			}
			
			class B {
			}
		''');
 
		tester.validate(model).assertError('notBoolean');
	}
	
	// Wrong type in println	
	@Test
	def testPrintlnParameterChecking1() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int[] a;
					System.out.println(a);
					
					return 0;
				}
			}
		''');
 
		tester.validate(model).assertError('notInt');
	}
	
	@Test
	def testPrintlnParameterChecking2() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					B b;
					System.out.println(b);
					
					return 0;
				}
			}
			
			class B {
			}
		''');
 
		tester.validate(model).assertError('notInt');
	}
	
	// Wrong type in assignment
	@Test
	def testArrayElementAssignmentChecking1() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int b;
					int c;
					
					b[2] = 	c;
					
					return 0;
				}
			}
		''');
 
		tester.validate(model).assertError('notArray');
	}
	
	@Test
	def testArrayElementAssignmentChecking2() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int[] b;
					boolean c;
					
					b[2] = 	c;
					
					return 0;
				}
			}
		''');
 
		tester.validate(model).assertError('notInt');
	}
	
	@Test
	def testArrayElementAssignmentChecking3() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int[] b;
					boolean c;
					int d;
					
					b[c] = 	d;
					
					return 0;
				}
			}
		''');
 
		tester.validate(model).assertError('notInt');
	}
	
	@Test
	def testAssignmentChecking1() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int a;
					boolean b;
					
					a = b;
					
					return 0;
				}
			}
		''');
 
		tester.validate(model).assertError('typeMismatch');
	}
	
	@Test
	def testAssignmentChecking2() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int a;
					B b;
					
					a = b;
					
					return 0;
				}
			}
			
			class B {
			}
		''');
 
		tester.validate(model).assertError('typeMismatch');
	}
	
	@Test
	def testAssignmentChecking3() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					B b;
					C c;
					
					b = c;
					
					return 0;
				}
			}
			
			class B {
			}
			
			class C {
			}
		''');
 
		tester.validate(model).assertError('typeMismatch');
	}
	
	// Wrong type in logic expression
	@Test
	def testLessParameterChecking1() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					boolean a;
					boolean b;
					int c;
					
					a = b && c;
					
					return 0;
				}
			}
		''');
 
		tester.validate(model).assertError('notBoolean');
	}

	@Test
	def testLessParameterChecking2() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					boolean a;
					B b;
					boolean c;
					
					a = b && c;
					
					return 0;
				}
			}
			
			class B {
			}
		''');
 
		tester.validate(model).assertError('notBoolean');
	}
	
	// Wrong type in less, addition or multiplication expression
	@Test
	def testIntExprParameterChecking1() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int a;
					boolean b;
					
					a = a < b;
					
					return 0;
				}
			}
		''');
 
		val statement = model.classDeclarations.get(1).methodDeclarations.get(0).statements.get(0);
		 
		tester.validator().checkIntExprParameter(statement.firstExpression);
		tester.diagnose().assertError('notInt');
	}
	
	@Test
	def testIntExprParameterChecking2() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int a;
					B b;
					
					a = a + b;
					
					return 0;
				}
			}
			
			class B {
			}
		''');
		
		val statement = model.classDeclarations.get(1).methodDeclarations.get(0).statements.get(0);
		 
		tester.validator().checkIntExprParameter(statement.firstExpression);
		tester.diagnose().assertError('notInt');
	}
	
	@Test
	def testIntExprParameterChecking3() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int a;
					B b;
					C c;
					
					a = b * c;
					
					return 0;
				}
			}
			
			class B {
			}
			
			class C {
			}
		''');
 
		val statement = model.classDeclarations.get(1).methodDeclarations.get(0).statements.get(0);
		 
		tester.validator().checkIntExprParameter(statement.firstExpression);
		tester.diagnose().assertError('notInt');
	}
	
	// Wrong type in negation expression
	@Test
	def testNegationParameterChecking1() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					boolean a;
					int b;
					
					a = !b;
					
					return 0;
				}
			}
		''');
 
		tester.validate(model).assertError('notBoolean');
	}
	
	@Test
	def testNegationParameterChecking2() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					boolean a;
					B b;
					
					a = !b;
					
					return 0;
				}
			}
			
			class B {
			}
		''');
 
		tester.validate(model).assertError('notBoolean');
	}
	
	// Wrong type in point expression
	@Test
	def testPointExpressionChecking1() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int a;
					int b;
					
					a = b.length;				
					
					return 0;
				}
			}
		''');
 
		tester.validate(model).assertError('wrongMethod');
	}
	
	@Test
	def testPointExpressionChecking2() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int a;
					B b;
					
					a = b.length;				
					
					return 0;
				}
			}
			
			class B {
			}
		''');
 
		tester.validate(model).assertError('wrongMethod');
	}
	
	@Test
	def testPointExpressionChecking3() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int a;
					int[] b;
					
					a = b.(length);				
					
					return 0;
				}
			}
		''');
 
		tester.validate(model).assertError('wrongMethod');
	}
	
	@Test
	def testPointExpressionChecking4() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int a;
					int[] b;
					
					a = b.length;				
					
					return 0;
				}
			}
		''');
 
		tester.validate(model).assertOK();
	}
	
	@Test
	def testPointExpressionChecking5() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					b a;
					int b;
					
					a = b.check();				
					
					return 0;
				}
			}
			
			class B {
				public boolean check() {
					return true;
				}
			}
		''');
 
		tester.validate(model).assertError('wrongMethod');
	}
	
	@Test
	def testPointExpressionChecking6() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int a;
					B b;
					
					a = b.method();				
					
					return 0;
				}
			}
			
			class B {
				public boolean check() {
					return true;
				}
			}
		''');
 
		tester.validate(model).assertError('wrongMethod');
	}
	
	@Test
	def testPointExpressionChecking7() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					boolean a;
					B b;
					
					a = b.check();				
					
					return 0;
				}
			}
			
			class B {
				public boolean check() {
					return true;
				}
			}
		''');
 
		tester.validate(model).assertOK();
	}
	
	// Wrong type in square brackets expression
	@Test
	def testSquareBracketsExpressionChecking() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int a;
					int b;
					int c;
					
					a = b[c];
					
					return 0;
				}
			}
		''');
 
		tester.validate(model).assertError('notArray');
	}
	
	@Test
	def testSquareBracketsExpressionChecking2() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int a;
					B b;
					int c;
					
					a = b[c];
					
					return 0;
				}
			}
			
			class B {
			}
		''');
 
		tester.validate(model).assertError('notArray');
	}
	
	@Test
	def testSquareBracketsExpressionChecking3() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int a;
					int[] b;
					boolean c;
					
					a = b[c];
					
					return 0;
				}
			}
		''');
 
		tester.validate(model).assertError('notInt');
	}
	
	@Test
	def testSquareBracketsExpressionChecking4() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int a;
					int[] b;
					B c;
					
					a = b[c];
					
					return 0;
				}
			}
			
			class B {
			}
		''');

		tester.validate(model).assertError('notInt');
	}
	
	// Wrong new int array capacity parameter
	@Test
	def testNewArrayParameterChecking1() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int[] a;
					boolean b;
					
					a = new int[b];
					return 0;
				}
			}
		''');
		
		val statement = model.classDeclarations.get(1).methodDeclarations.get(0).statements.get(0);
		 
		tester.validator().checkNewArrayParameter(statement.firstExpression);
		tester.diagnose().assertError('notInt');
	}
	
	@Test
	def testNewArrayParameterChecking2() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int[] a;
					B b;
					
					a = new int[b];
					return 0;
				}
			}
			
			class B {
			}
		''');
		
		val statement = model.classDeclarations.get(1).methodDeclarations.get(0).statements.get(0);
		 
		tester.validator().checkNewArrayParameter(statement.firstExpression);
		tester.diagnose().assertError('notInt');
	}
	
	// Couldn't instantiate a primitive type
	@Test
	def testNewPrimitiveTypeExpressionChecking() {
		val model = parser.parse(MAIN_CLASS_CODE + '''
			class A {
				public int method() {
					int a;
					
					a = new int();
				}
			}
		''');
		
		val statement = model.classDeclarations.get(1).methodDeclarations.get(0).statements.get(0);
		 
		tester.validator().checkNewPrimitiveTypeExpression(statement.firstExpression);
		tester.diagnose().assertError('wrongInstantiation');
	}
}
